using UnityEngine;
using System.Collections;
using Unity.VisualScripting;
using static UnityEngine.GraphicsBuffer;

public class KCameraController : MonoBehaviour
{
    //---------------------------------------------
    public Transform _targetTransform;      //Target
    public Transform _cameraTransform;

    public Vector3 targetOffset = new Vector3(0, 1, 0);    //위치

    public float fDistance = 15.0f;          //Editor 우선 참조
    public float fPitch = 30.0f;
    public float fYaw = 0.0f;

    float minimumX = -360F;
    float maximumX = 360F;
    float minimumY = -0F;   // fPitch max
    float maximumY = 90F;
    float minimumZ = 1F;    // fDistance max
    float maximumZ = 30F;

    private float fVelocity = 0.0f;
    float fDistance_cur;
    float fSmoothTime = 0.1F;   // smooth, smaller is faster.

    private float angleVelocity = 0.0f;
    private float angularSmoothTime = 0.2f;
    private float angularMaxSpeed = 15.0f;
    public float moveSpeed = 5f;

    // ✅ 추가된 변수: 클릭 이동용
    private Vector3 _moveTargetPosition;
    private bool _isMoving = false;

    //---------------------------------------------
    void Awake()
    {
        if (!_cameraTransform && Camera.main)
            _cameraTransform = Camera.main.transform;
        if (!_cameraTransform)
        {
            Debug.Log("Please assign a camera to the CameraController script.");
            enabled = false;
        }

        if (!_targetTransform)
        {
            Debug.Log("Please assign a target Transform.");
        }
    }

    void Start()
    {
    }

    void Update()
    {
        // 카메라 회전 조정 (우클릭)
        if (Input.GetMouseButton(1))
        {
            fYaw += Input.GetAxis("Mouse X");
            fPitch -= Input.GetAxis("Mouse Y");
            fPitch = Mathf.Clamp(fPitch, minimumY, maximumY);
        }

        fDistance -= Input.GetAxis("Mouse ScrollWheel");
        fDistance = Mathf.Clamp(fDistance, minimumZ, maximumZ);

        Vector3 inputDir = new Vector3(Input.GetAxis("Horizontal"), 0, Input.GetAxis("Vertical"));

        if (inputDir != Vector3.zero)
        {
            Vector3 camForward = Camera.main.transform.forward;
            //Debug.Log("camForward" + Camera.main.transform.forward);
            Vector3 camRight = Camera.main.transform.right;
            //Debug.Log("camRight" + Camera.main.transform.right);
            // 수평 방향만 사용 (y 제거)
            camForward.y = 0;
            camRight.y = 0;
            camForward.Normalize();
            camRight.Normalize();

            // 최종 이동 방향
            Vector3 moveDir = camForward * inputDir.z + camRight * inputDir.x;

            // 이동
            transform.position += moveDir * moveSpeed * Time.deltaTime;

            // 회전
            Quaternion targetRotation = Quaternion.LookRotation(moveDir);
            transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, 10f * Time.deltaTime);
        }

        // 기존 기능 - 왼클릭 시 타겟을 바라보는 코드
        if (Input.GetMouseButtonDown(0))
        {
            Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
            RaycastHit hit;

            if (Physics.Raycast(ray, out hit))
            {
                _moveTargetPosition = hit.point;
                _moveTargetPosition.y = transform.position.y; // y 고정
                _isMoving = true;
            }

            //Quaternion q = transform.localRotation; q.x = 0; q.z = 0;
            //transform.localRotation = q;
            //transform.LookAt(_targetTransform);

            Debug.Log("aa");
        }

        if (_isMoving)
        {
            Vector3 direction = (_moveTargetPosition - transform.position).normalized;
            direction.y = 0;

            if (direction != Vector3.zero)
            {
                Quaternion targetRotation = Quaternion.LookRotation(direction);
                transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, 10f * Time.deltaTime);
            }

            float distance = Vector3.Distance(transform.position, _moveTargetPosition);
            float moveStep = moveSpeed * Time.deltaTime;

            if (distance > moveStep)
            {
                transform.position += direction * moveStep;
            }
            else
            {
                transform.position = _moveTargetPosition;
                _isMoving = false;
            }
        }
    }

    void LateUpdate()
    {
        if (!_targetTransform) return;

        Quaternion currentRotation = Quaternion.Euler(fPitch, fYaw, 0);
        Vector3 targetPos = _targetTransform.position + targetOffset;
        _cameraTransform.position = targetPos + currentRotation * Vector3.back * fDistance;

        Vector3 relativePos = targetPos - _cameraTransform.position;
        _cameraTransform.rotation = Quaternion.LookRotation(relativePos);
    }

    void MoveToTarget(float _speed)
    {
        transform.rotation = Quaternion.Euler(0, 45, 0);
        Vector3 m_Move = transform.forward * _speed * Time.deltaTime;
        transform.position += m_Move;
    }
}
